var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SymbolDispatch","category":"page"},{"location":"#SymbolDispatch","page":"Home","title":"SymbolDispatch","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SymbolDispatch.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It exports macro @symboldispatch","category":"page"},{"location":"","page":"Home","title":"Home","text":"@symboldispatch","category":"page"},{"location":"#SymbolDispatch.@symboldispatch","page":"Home","title":"SymbolDispatch.@symboldispatch","text":"@symboldispatch foo(Val{:asymbol}, ...) = body\n\nThis macro takes a function definition whose first argument is a valuetype of a symbol and creates two more methods, a dispatch and a default fallback:\n\nfoo(s::Symbol, ...) = foo(Val(s), ...)\n\nfoo(::Val{T}, ...) where T = ArgumentError(\"Its defined for <possible symbols>\")\n\nIt helps to implement the Singleton type dispatch pattern  without exposing the usage of valuetypes to the user of the function. Depending on the given Symbol s, the respective method is invoked.\n\nNote that additional methods of foo for other possible symbols  should be defined without the macro in order to avoid redifinition of the  dispatch and fallback method.\n\nmodule mod_tmp\n    using SymbolDispatch\n    @symboldispatch _bar(::Val{:method1}) = \"method for :method1\"\n    _bar(::Val{:method2}) = \"method for :method2\"\nend\n#mod_tmp._bar(:symbol_without_dispatch) # reporting :method1,:method2\nmod_tmp._bar(:method1) == \"method for :method1\"\n\n\n\n\n\n","category":"macro"}]
}
