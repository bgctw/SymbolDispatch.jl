var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SymbolDispatch","category":"page"},{"location":"#SymbolDispatch","page":"Home","title":"SymbolDispatch","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SymbolDispatch.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It exports macros @symboldispatch and @symboldispatch_pos2","category":"page"},{"location":"","page":"Home","title":"Home","text":"@symboldispatch\n@symboldispatch_pos2","category":"page"},{"location":"#SymbolDispatch.@symboldispatch","page":"Home","title":"SymbolDispatch.@symboldispatch","text":"@symboldispatch foo(Val{:asymbol}, ...) = body\n\nThis macro takes a function definition whose first argument is a valuetype of a symbol and creates two more methods, a dispatch and a default fallback:\n\nfoo(s::Symbol, ...) = foo(Val(s), ...)\n\nfoo(::Val{T}, ...) where T = ArgumentError(\"Its defined for <possible symbols>\")\n\nIt helps to implement the Singleton type dispatch pattern  without exposing the usage of valuetypes to the user of the function. Depending on the given Symbol s, the respective method is invoked.\n\nNote that additional methods of foo for other possible symbols  should be defined without the macro in order to avoid redifinition of the  dispatch and fallback method.\n\nmodule mod_tmp\n    using SymbolDispatch\n    @symboldispatch _bar(::Val{:method1}) = \"method for :method1\"\n    _bar(::Val{:method2}) = \"method for :method2\"\nend\n#mod_tmp._bar(:symbol_without_dispatch) # reporting :method1,:method2\nmod_tmp._bar(:method1) == \"method for :method1\"\n\n\n\n\n\n","category":"macro"},{"location":"#SymbolDispatch.@symboldispatch_pos2","page":"Home","title":"SymbolDispatch.@symboldispatch_pos2","text":"@symboldispatch_pos2 foo(_, Val{:asymbol}, ...) = body\n\nSimilar to @symboldispatch, adds a a dispatch and a default method, but takes a function where the second argument is a valuetype of a symbol is used to dispatch.\n\nfoo(x1, s::Symbol, ...) = foo(x1, Val(s), ...)\n\nfoo(_, ::Val{T}, ...) where T = ArgumentError(\"Its defined for <possible symbols>\")\n\nThis helps to support different dispatches of mutating methods, where the  first argument is conventionally the mutated element.\n\nmodule mod_tmp2\n    using SymbolDispatch\n    @symboldispatch_pos2 _bar!(x, ::Val{:method1}) = \"method for :method1\"\n    _bar!(x, ::Val{:method2}) = \"method for :method2\"\nend\n#mod_tmp2._bar!([1], :symbol_without_dispatch) # reporting :method1,:method2\nmod_tmp2._bar!([1], :method1) == \"method for :method1\"\n\n\n\n\n\n","category":"macro"}]
}
